##########################################
# WARNING: This is an auto-generated file.
# DO NOT EDIT THIS FILE DIRECTLY
# ANY EDITS WILL BE LOST
##########################################
from dataclasses import dataclass, field
from typing import Any, Optional

from ._ContainerDefinition import ContainerDefinition
from ._EnvironmentVariable import EnvironmentVariable
from ._Input import Input
from ._Model import Model
from ._Output import Output
from ._Template import Template
from ._Tool import Tool


@dataclass
class Prompty:
    """The following is a specification for defining AI agents with structured metadata, inputs, outputs, tools, and templates.It provides a way to create reusable and composable AI agents that can be executed with specific configurations.The specification includes metadata about the agent, model configuration, input parameters, expected outputs,available tools, and template configurations for prompt rendering.These can be written in a markdown format or in a pure YAML format.
    Attributes
    ----------
    kind : str
        Kind represented by the document
    id : Optional[str]
        Unique identifier for the document
    version : Optional[str]
        Document version
    name : str
        Human-readable name of the agent
    description : Optional[str]
        Description of the agent's capabilities and purpose
    metadata : Optional[dict[str, Any]]
        Additional metadata including authors, tags, and other arbitrary properties
    model : Model
        Model configuration used for execution
    inputs : Optional[list[Input]]
        Input parameters that participate in template rendering
    outputs : Optional[list[Output]]
        Expected output format and structure from the agent
    tools : Optional[list[Tool]]
        Tools available to the agent for extended functionality
    template : Optional[Template]
        Template configuration for prompt rendering
    instructions : Optional[str]
        Give your agent clear directions on what to do and how to do it. Include specific tasks, their order, and any special instructions like tone or engagement style. (can use this for a pure yaml declaration or as content in the markdown format)
    additionalInstructions : Optional[str]
        Additional instructions or context for the agent, can be used to provide extra guidance (can use this for a pure yaml declaration)
    """

    kind: str = field(default="prompt")
    id: Optional[str] = field(default="")
    version: Optional[str] = field(default="")
    name: str = field(default="")
    description: Optional[str] = field(default="")
    metadata: Optional[dict[str, Any]] = field(default_factory=dict)
    model: Model = field(default_factory=Model)
    inputs: Optional[list[Input]] = field(default_factory=list)
    outputs: Optional[list[Output]] = field(default_factory=list)
    tools: Optional[list[Tool]] = field(default_factory=list)
    template: Optional[Template] = field(default=None)
    instructions: Optional[str] = field(default="")
    additionalInstructions: Optional[str] = field(default="")

    @staticmethod
    def load(data: Any) -> "Prompty":
        """Load a Prompty instance."""

        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for Prompty: {data}")

        # load polymorphic Prompty instance
        instance = Prompty.load_kind(data)
        if data is not None and "kind" in data:
            instance.kind = data["kind"]
        if data is not None and "id" in data:
            instance.id = data["id"]
        if data is not None and "version" in data:
            instance.version = data["version"]
        if data is not None and "name" in data:
            instance.name = data["name"]
        if data is not None and "description" in data:
            instance.description = data["description"]
        if data is not None and "metadata" in data:
            instance.metadata = data["metadata"]
        if data is not None and "model" in data:
            instance.model = Model.load(data["model"])
        if data is not None and "inputs" in data:
            instance.inputs = Prompty.load_inputs(data["inputs"])
        if data is not None and "outputs" in data:
            instance.outputs = Prompty.load_outputs(data["outputs"])
        if data is not None and "tools" in data:
            instance.tools = Prompty.load_tools(data["tools"])
        if data is not None and "template" in data:
            instance.template = Template.load(data["template"])
        if data is not None and "instructions" in data:
            instance.instructions = data["instructions"]
        if data is not None and "additionalInstructions" in data:
            instance.additionalInstructions = data["additionalInstructions"]
        return instance

    @staticmethod
    def load_inputs(data: dict | list) -> list[Input]:
        if isinstance(data, dict):
            # convert simple named inputs to list of Input
            data = [{"name": k, **v} for k, v in data.items()]

        return [Input.load(item) for item in data]

    @staticmethod
    def load_outputs(data: dict | list) -> list[Output]:
        if isinstance(data, dict):
            # convert simple named outputs to list of Output
            data = [{"name": k, **v} for k, v in data.items()]

        return [Output.load(item) for item in data]

    @staticmethod
    def load_tools(data: dict | list) -> list[Tool]:
        if isinstance(data, dict):
            # convert simple named tools to list of Tool
            data = [{"name": k, **v} for k, v in data.items()]

        return [Tool.load(item) for item in data]

    @staticmethod
    def load_kind(data: dict) -> "Prompty":
        # load polymorphic Prompty instance
        if data is not None and "kind" in data:
            discriminator_value = data["kind"]
            if discriminator_value == "container":
                return PromptyContainer.load(data)
            else:
                # create new instance (stop recursion)
                return Prompty()
        else:
            # create new instance
            return Prompty()


@dataclass
class PromptyContainer(Prompty):
    """
    Attributes
    ----------
    kind : str
        Type of agent, e.g., 'prompt' or 'container'
    protocol : str
        Protocol used by the containerized agent
    container : ContainerDefinition
        Container definition including registry and scaling information
    environmentVariables : Optional[list[EnvironmentVariable]]
        Environment variables to set in the hosted agent container.
    """

    kind: str = field(default="container")
    protocol: str = field(default="responses")
    container: ContainerDefinition = field(default_factory=ContainerDefinition)
    environmentVariables: Optional[list[EnvironmentVariable]] = field(default_factory=list)

    @staticmethod
    def load(data: Any) -> "PromptyContainer":
        """Load a PromptyContainer instance."""

        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for PromptyContainer: {data}")

        # create new instance
        instance = PromptyContainer()
        if data is not None and "kind" in data:
            instance.kind = data["kind"]
        if data is not None and "protocol" in data:
            instance.protocol = data["protocol"]
        if data is not None and "container" in data:
            instance.container = ContainerDefinition.load(data["container"])
        if data is not None and "environmentVariables" in data:
            instance.environmentVariables = PromptyContainer.load_environmentVariables(data["environmentVariables"])
        return instance

    @staticmethod
    def load_environmentVariables(data: dict | list) -> list[EnvironmentVariable]:
        if isinstance(data, dict):
            # convert simple named environmentVariables to list of EnvironmentVariable
            # simple expansion to "name", "value"
            data = [{"name": k, "value": v} for k, v in data.items()]

        return [EnvironmentVariable.load(item) for item in data]
