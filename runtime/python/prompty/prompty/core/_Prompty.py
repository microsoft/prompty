##########################################
# WARNING: This is an auto-generated file.
# DO NOT EDIT THIS FILE DIRECTLY
# ANY EDITS WILL BE LOST
##########################################
from dataclasses import dataclass, field
from typing import Any, Optional

from ._ContainerDefinition import ContainerDefinition
from ._EnvironmentVariable import EnvironmentVariable
from ._Input import Input
from ._Model import Model
from ._Output import Output
from ._Parameter import Parameter
from ._Template import Template
from ._Tool import Tool


@dataclass
class Prompty:
    """The following is a specification for defining AI agents with structured metadata, inputs, outputs, tools, and templates.It provides a way to create reusable and composable AI agents that can be executed with specific configurations.The specification includes metadata about the agent, model configuration, input parameters, expected outputs,available tools, and template configurations for prompt rendering.These can be written in a markdown format or in a pure YAML format.
    Attributes
    ----------
    kind : str
        Kind represented by the document
    id : Optional[str]
        Unique identifier for the document
    version : Optional[str]
        Document version
    name : str
        Human-readable name of the agent
    description : Optional[str]
        Description of the agent's capabilities and purpose
    metadata : Optional[dict[str, Any]]
        Additional metadata including authors, tags, and other arbitrary properties
    model : Model
        Primary AI model configuration for the agent
    inputs : Optional[list[Input]]
        Input parameters that participate in template rendering
    outputs : Optional[list[Output]]
        Expected output format and structure from the agent
    tools : Optional[list[Tool]]
        Tools available to the agent for extended functionality
    template : Optional[Template]
        Template configuration for prompt rendering
    instructions : Optional[str]
        Give your agent clear directions on what to do and how to do it. Include specific tasks, their order, and any special instructions like tone or engagement style. (can use this for a pure yaml declaration or as content in the markdown format)
    additionalInstructions : Optional[str]
        Additional instructions or context for the agent, can be used to provide extra guidance (can use this for a pure yaml declaration)
    """

    kind: str = field(default="prompt")
    id: Optional[str] = field(default="")
    version: Optional[str] = field(default="")
    name: str = field(default="")
    description: Optional[str] = field(default="")
    metadata: Optional[dict[str, Any]] = field(default_factory=dict)
    model: Model = field(default_factory=Model)
    inputs: Optional[list[Input]] = field(default_factory=list)
    outputs: Optional[list[Output]] = field(default_factory=list)
    tools: Optional[list[Tool]] = field(default_factory=list)
    template: Optional[Template] = field(default=None)
    instructions: Optional[str] = field(default="")
    additionalInstructions: Optional[str] = field(default="")

    @staticmethod
    def load(data: Any) -> "Prompty":
        """Load a Prompty instance."""

        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for Prompty: {data}")

        # load polymorphic Prompty instance
        instance = Prompty.load_kind(data)
        if data is not None and "kind" in data:
            instance.kind = data["kind"]
        if data is not None and "id" in data:
            instance.id = data["id"]
        if data is not None and "version" in data:
            instance.version = data["version"]
        if data is not None and "name" in data:
            instance.name = data["name"]
        if data is not None and "description" in data:
            instance.description = data["description"]
        if data is not None and "metadata" in data:
            instance.metadata = data["metadata"]
        if data is not None and "model" in data:
            instance.model = Model.load(data["model"])
        if data is not None and "inputs" in data:
            instance.inputs = Prompty.load_inputs(data["inputs"])
        if data is not None and "outputs" in data:
            instance.outputs = Prompty.load_outputs(data["outputs"])
        if data is not None and "tools" in data:
            instance.tools = Prompty.load_tools(data["tools"])
        if data is not None and "template" in data:
            instance.template = Template.load(data["template"])
        if data is not None and "instructions" in data:
            instance.instructions = data["instructions"]
        if data is not None and "additionalInstructions" in data:
            instance.additionalInstructions = data["additionalInstructions"]
        return instance

    @staticmethod
    def load_inputs(data: dict | list) -> list[Input]:
        if isinstance(data, dict):
            # convert simple named inputs to list of Input
            data = [{"name": k, **v} for k, v in data.items()]

        return [Input.load(item) for item in data]

    @staticmethod
    def load_outputs(data: dict | list) -> list[Output]:
        if isinstance(data, dict):
            # convert simple named outputs to list of Output
            data = [{"name": k, **v} for k, v in data.items()]

        return [Output.load(item) for item in data]

    @staticmethod
    def load_tools(data: dict | list) -> list[Tool]:
        if isinstance(data, dict):
            # convert simple named tools to list of Tool
            data = [{"name": k, **v} for k, v in data.items()]

        return [Tool.load(item) for item in data]

    @staticmethod
    def load_kind(data: dict) -> "Prompty":
        # load polymorphic Prompty instance
        if data is not None and "kind" in data:
            discriminator_value = data["kind"]
            if discriminator_value == "manifest":
                return PromptyManifest.load(data)
            elif discriminator_value == "container":
                return PromptyContainer.load(data)
            else:
                # create new instance (stop recursion)
                return Prompty()
        else:
            # create new instance
            return Prompty()


@dataclass
class PromptyManifest(Prompty):
    """The following represents a manifest that can be used to create agents dynamically.It includes a list of models that the publisher of the manifest has tested andhas confidence will work with an instantiated prompt agent.The manifest also includes parameters that can be used to configure the agent&#39;s behavior.These parameters include values that can be used as publisher parameters that canbe used to describe additional variables that have been tested and are known to work.Variables described here are then used to project into a prompt agent that can be executed.Once parameters are provided, these can be referenced in the manifest using the following notation:`${param:MyParameter}`This allows for dynamic configuration of the agent based on the provided parameters.(This notation is used elsewhere, but only the `param` scope is supported here)
    Attributes
    ----------
    kind : str
        Type of agent, e.g., 'manifest'
    models : list[Model]
        Additional models that are known to work with this prompt
    parameters : list[Parameter]
        Parameters for configuring the agent's behavior and execution
    """

    kind: str = field(default="manifest")
    models: list[Model] = field(default_factory=list)
    parameters: list[Parameter] = field(default_factory=list)

    @staticmethod
    def load(data: Any) -> "PromptyManifest":
        """Load a PromptyManifest instance."""

        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for PromptyManifest: {data}")

        # create new instance
        instance = PromptyManifest()
        if data is not None and "kind" in data:
            instance.kind = data["kind"]
        if data is not None and "models" in data:
            instance.models = PromptyManifest.load_models(data["models"])
        if data is not None and "parameters" in data:
            instance.parameters = PromptyManifest.load_parameters(data["parameters"])
        return instance

    @staticmethod
    def load_models(data: dict | list) -> list[Model]:
        if isinstance(data, dict):
            # convert simple named models to list of Model
            data = [{"name": k, **v} for k, v in data.items()]

        return [Model.load(item) for item in data]

    @staticmethod
    def load_parameters(data: dict | list) -> list[Parameter]:
        if isinstance(data, dict):
            # convert simple named parameters to list of Parameter
            data = [{"name": k, **v} for k, v in data.items()]

        return [Parameter.load(item) for item in data]


@dataclass
class PromptyContainer(Prompty):
    """The following represents a containerized agent that can be deployed and hosted.It includes details about the container image, registry information, and environment variables.This model allows for the definition of agents that can run in isolated environments,making them suitable for deployment in various cloud or on-premises scenarios.The containerized agent can communicate using specified protocols and can be scaledbased on the provided configuration.
    Attributes
    ----------
    kind : str
        Type of agent, e.g., 'container'
    protocol : str
        Protocol used by the containerized agent
    container : ContainerDefinition
        Container definition including registry and scaling information
    environmentVariables : Optional[list[EnvironmentVariable]]
        Environment variables to set in the hosted agent container.
    """

    kind: str = field(default="container")
    protocol: str = field(default="responses")
    container: ContainerDefinition = field(default_factory=ContainerDefinition)
    environmentVariables: Optional[list[EnvironmentVariable]] = field(default_factory=list)

    @staticmethod
    def load(data: Any) -> "PromptyContainer":
        """Load a PromptyContainer instance."""

        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for PromptyContainer: {data}")

        # create new instance
        instance = PromptyContainer()
        if data is not None and "kind" in data:
            instance.kind = data["kind"]
        if data is not None and "protocol" in data:
            instance.protocol = data["protocol"]
        if data is not None and "container" in data:
            instance.container = ContainerDefinition.load(data["container"])
        if data is not None and "environmentVariables" in data:
            instance.environmentVariables = PromptyContainer.load_environmentVariables(data["environmentVariables"])
        return instance

    @staticmethod
    def load_environmentVariables(data: dict | list) -> list[EnvironmentVariable]:
        if isinstance(data, dict):
            # convert simple named environmentVariables to list of EnvironmentVariable
            # simple expansion to "name", "value"
            data = [{"name": k, "value": v} for k, v in data.items()]

        return [EnvironmentVariable.load(item) for item in data]
