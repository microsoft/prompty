##########################################
# WARNING: This is an auto-generated file.
# DO NOT EDIT THIS FILE DIRECTLY
# ANY EDITS WILL BE LOST
##########################################
from dataclasses import dataclass, field
from typing import Any, Optional


@dataclass
class Input:
    """Represents a single input property for a prompt.* This model defines the structure of input properties that can be used in prompts,including their type, description, whether they are required, and other attributes.* It allows for the definition of dynamic inputs that can be filled with dataand processed to generate prompts for AI models.
    Attributes
    ----------
    name : str
        Name of the input property
    kind : str
        The data type of the input property
    description : Optional[str]
        A short description of the input property
    required : Optional[bool]
        Whether the input property is required
    strict : Optional[bool]
        Whether the input property can emit structural text when parsing output
    default : Optional[Any]
        The default value of the input - this represents the default value if none is provided
    sample : Optional[Any]
        A sample value of the input for examples and tooling
    """

    name: str = field(default="")
    kind: str = field(default="")
    description: Optional[str] = field(default="")
    required: Optional[bool] = field(default=False)
    strict: Optional[bool] = field(default=False)
    default: Optional[Any] = field(default=None)
    sample: Optional[Any] = field(default=None)

    @staticmethod
    def load(data: Any) -> "Input":
        """Load a Input instance."""
        # handle alternate representations
        if isinstance(data, bool):
            data = {"kind": "boolean", "sample": data}
        if isinstance(data, float):
            data = {"kind": "float", "sample": data}
        if isinstance(data, int):
            data = {"kind": "integer", "sample": data}
        if isinstance(data, str):
            data = {"kind": "string", "sample": data}

        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for Input: {data}")

        # load polymorphic Input instance
        instance = Input.load_kind(data)
        if data is not None and "name" in data:
            instance.name = data["name"]
        if data is not None and "kind" in data:
            instance.kind = data["kind"]
        if data is not None and "description" in data:
            instance.description = data["description"]
        if data is not None and "required" in data:
            instance.required = data["required"]
        if data is not None and "strict" in data:
            instance.strict = data["strict"]
        if data is not None and "default" in data:
            instance.default = data["default"]
        if data is not None and "sample" in data:
            instance.sample = data["sample"]
        return instance

    @staticmethod
    def load_kind(data: dict) -> "Input":
        # load polymorphic Input instance
        if data is not None and "kind" in data:
            discriminator_value = data["kind"]
            if discriminator_value == "array":
                return ArrayInput.load(data)
            elif discriminator_value == "object":
                return ObjectInput.load(data)
            else:
                # create new instance (stop recursion)
                return Input()
        else:
            # create new instance
            return Input()


@dataclass
class ArrayInput(Input):
    """Represents an array output property.This extends the base Output model to represent an array of items.
    Attributes
    ----------
    kind : str

    items : Input
        The type of items contained in the array
    """

    kind: str = field(default="array")
    items: Input = field(default_factory=Input)

    @staticmethod
    def load(data: Any) -> "ArrayInput":
        """Load a ArrayInput instance."""

        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for ArrayInput: {data}")

        # create new instance
        instance = ArrayInput()
        if data is not None and "kind" in data:
            instance.kind = data["kind"]
        if data is not None and "items" in data:
            instance.items = Input.load(data["items"])
        return instance


@dataclass
class ObjectInput(Input):
    """Represents an object output property.This extends the base Output model to represent a structured object.
    Attributes
    ----------
    kind : str

    properties : list[Input]
        The properties contained in the object
    """

    kind: str = field(default="object")
    properties: list[Input] = field(default_factory=list)

    @staticmethod
    def load(data: Any) -> "ObjectInput":
        """Load a ObjectInput instance."""

        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for ObjectInput: {data}")

        # create new instance
        instance = ObjectInput()
        if data is not None and "kind" in data:
            instance.kind = data["kind"]
        if data is not None and "properties" in data:
            instance.properties = ObjectInput.load_properties(data["properties"])
        return instance

    @staticmethod
    def load_properties(data: dict | list) -> list[Input]:
        if isinstance(data, dict):
            # convert simple named properties to list of Input
            data = [{"name": k, **v} for k, v in data.items()]

        return [Input.load(item) for item in data]
