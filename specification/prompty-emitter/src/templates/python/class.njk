@dataclass
class {{ node.typeName.name }}{% if node.base %}({{ node.base.name }}){% endif %}{% if node.isAbstract %}(ABC){% endif %}:
    """{%- for line in node.description.split('\n') -%}
    {{ line }}
    {%- endfor %}

    {%- if node.properties.length > 0 %}
    Attributes
    ----------
    {%- for prop in node.properties %}
    {{ prop.name }} : {{ renderType(prop) | safe }}
        {{ prop.description | safe }}
    {%- endfor %}
    """ 

    {%- for prop in node.properties %}
    {{ prop.name }}: {{ renderType(prop) | safe }}{{ renderDefault(prop) | safe }}
    {%- endfor %}

    @staticmethod
    def load(data: Any) -> "{{ node.typeName.name }}":
        """Load a {{ node.typeName.name }} instance."""
        
        {%- if node.alternates.length > 0 %}
        # handle alternate representations
        {%- for alt in alternates %}
        if isinstance(data, {{ alt.scalar }}):
            data = {{ alt.alternate | safe }}
        {%- endfor %}
        {%- endif %}
        
        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for {{ node.typeName.name }}: {data}")
        {% if polymorphicTypes %}
        # load polymorphic {{ node.typeName.name }} instance
        instance = {{ node.typeName.name }}.load_{{ node.discriminator }}(data)
        {% else %}
        # create new instance
        instance = {{ node.typeName.name }}()
        {% endif -%}
        {% for prop in node.properties -%}
        if data is not None and "{{ prop.name }}" in data:
            {{ renderSetInstance(prop, "instance", "data") | safe }}
        {% endfor -%}
        return instance

    {% for collection in collectionTypes %}
    @staticmethod
    def load_{{ collection.prop.name }}(data: dict | list) -> list[{{ collection.prop.typeName.name }}]:
        if isinstance(data, dict):
            # convert simple named {{ collection.prop.name }} to list of {{ collection.prop.typeName.name }}
            {%- if collection.type.length == 1 %}
            # simple expansion to "name", "{{collection.type[0]}}"
            data = [ {"name": k, "{{collection.type[0]}}": v} for k, v in data.items() ]
            {% else %}
            data = [ {"name": k, **v} for k, v in data.items() ]
            {% endif %}
        return [{{ collection.prop.typeName.name }}.load(item) for item in data]
    {%- endfor %}

    {%- if polymorphicTypes %}
    @staticmethod
    def load_{{ node.discriminator }}(data: dict) -> "{{ node.typeName.name }}":
        # load polymorphic {{ node.typeName.name }} instance
        if data is not None and "{{ node.discriminator }}" in data:
            discriminator_value = data["{{ node.discriminator }}"]
            {%- for type in polymorphicTypes.types %}
            {% if loop.first %}if{% else %}elif{% endif %} discriminator_value == "{{ type.value }}":
                return {{ type.instance.typeName.name }}.load(data)
            {%- endfor %}
            {%- if polymorphicTypes.default %}
            else:
                {%- if polymorphicTypes.default.instance.typeName.name == node.typeName.name %}
                # create new instance (stop recursion)
                return {{ node.typeName.name }}()
                {%- else %}
                # load default instance
                return {{ polymorphicTypes.default.instance.typeName.name }}.load(data)
                {%- endif -%}
            {%- else %}
            else:
                raise ValueError(f"Unknown {{ node.typeName.name }} discriminator value: {discriminator_value}")
            {%- endif %}
        else:
            {%- if node.isAbstract %}
            raise ValueError("Missing {{ node.typeName.name }} discriminator property: '{{ node.discriminator }}'")
            {%- else %}
            # create new instance
            return {{ node.typeName.name }}()
            {% endif %}

    {%- endif %}
    {%- endif %}